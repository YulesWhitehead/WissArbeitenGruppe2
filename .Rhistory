result[i, 7] <- median(var_data)
result[i, 8] <- q1
result[i, 9] <- q2
result[i, 10] <- q2 - q1
result[i, 11] <- Mean
result[i, 12] <- var(var_data)
result[i, 13] <- Sd
result[i, 14] <- Sd / Mean
result[i, 15] <- skewness(var_data)
result[i, 16] <- kurtosis(var_data)
}
# Rueckgabe der Ergebnismatrix als Dataframe
return(as.data.frame(result))
}
#a-ii
# kateg_stat - Funktion zur Berechnung deskriptiver Statistiken fuer kategoriale
#              Variablen
#
# Eingabe:
# data       - Datensatz, fuer den die Statistiken berechnet werden sollen
#
# Ausgabe:
# result     - Ergebnismatrix als Dataframe mit allen berechneten Statistiken
kateg_stat <- function(data){
# Erstellen einer leeren Ergebnismatrix
result <- matrix(NA, nrow = ncol(data), ncol = 5)
colnames(result) <- c("Variable", "Anzahl", "NA-Anzahl", "Modalwert",
"Relative Haeufigkeit")
# Iteration über die Variablen im Datensatz
for(i in 1:ncol(data)) {
var_name <- names(data)[i]
var_data <- data[[i]]
# Berechnung der Modalwert
modalwert <- moda(var_data)
# Berechnung der relativen Haeufigkeit
rel_h <- table(var_data) / length(var_data)
# Speichern der berechneten Statistiken in die Ergebnismatrix
result[i, 1] <- var_name
result[i, 2] <- length(var_data)
result[i, 3] <- sum(is.na(var_data))
result[i, 4] <- modalwert
result[i, 5] <- rel_h[as.character(modalwert)]
# Nur die relative Haeufigkeit des Modalwerts speichern
}
# Rückgabe der Ergebnismatrix als Dataframe
return(as.data.frame(result))
}
#a-iii
# kat_stat -  Funktion zur Berechnung bivariater deskriptiver Statistiken fuer
#             den Zusammenhang zweier kategorialer Variablen
#
# Eingabe:
# data1     - Vektor der Auspraegungen der ersten kategorialen Variable
# data2     - Vektor der Auspraegungen der zweiten kategorialen Variable
#
# Ausgabe:
# result    - benannter Vektor mit Cramers V und dem normierten
#             Kontingenzkoeffizienen nach Pearson
kat_stat <- function(data1, data2) {
c(Cramer = CramersV(data1, data2), normKont = normKontingenz(data1, data2))
}
#a-iv
# Funktion zur Analyse des Zusammenhangs zwischen einer metrischen und einer
#dichotomen Variable
analyzeMetricDichotomous <- function(metricVar, dichotomousVar) {
# Vorbereitung der Daten mit der Helfer-Funktion
preparedData <- prepareDataForAnalysis(metricVar, dichotomousVar)
metricVar <- preparedData$metricVar
dichotomousVar <- preparedData$dichotomousVar
# Berechnung der Mittelwerte für jede Gruppe der dichotomen Variable
means <- tapply(metricVar, dichotomousVar, mean, na.rm = TRUE)
# Durchführung eines t-Tests
t.testResult <- t.test(metricVar ~ dichotomousVar)
# Berechnung der Standardabweichungen für jede Gruppe
sds <- tapply(metricVar, dichotomousVar, sd, na.rm = TRUE)
# Ausgabe der Ergebnisse
list(
Means = means,
StandardDeviations = sds,
TTest = t.testResult
)
}
#
#* Diese Funktion visualisiert alle kategoriellen Variablen eines gegebenen
#* Dataframes.
#* "dataframe" enthält den Dataframe in welchem die Daten gespeichert sind,
#* "a" und "b" geben an die viele Plots pro Reihe/Spalte am Ende angezeigt
#* werden sollen. Um alle Plots einzeln zu bekommen beide auf 1 setzen.
create_categorical_plot <- function(dataframe, a = 1, b = 1) {
n <- length(dataframe[,1])
categorical_vars <- sapply(dataframe, is.factor)
par(mfrow = c(a, b))
# Plot für jede kategoriale Variable erstellen
for (col in names(dataframe)[categorical_vars]) {
cat_levels <- levels(dataframe[[col]])
cat_counts <- table(dataframe[[col]])/n
# Balkendiagramm erstellen
barplot(cat_counts, main = paste("Barplot for", col),
xlab = col, ylab = "Frequency", col = rainbow(length(cat_levels)))
}
}
attach(data)
#Ueberblick von Daten und deren Auspraegungen
str(data)
# Teildatensaetze
data_metrisch <- data[, 5:8]
data_kategorial <- data[, c(2:4, 9:12)]
# Berechnung von deskriptiven Statistiken fuer metrische Variablen
metr_stat(data_metrisch)
# Berechnung von deskriptiven Statistiken fuer kategoriale Variablen
kateg_stat(data_kategorial)
# a-iii Zusammenhang zwischen zwei kategorialen Variablen (z.B. Geschlecht und Überlebensstatus)
zusammenhang_Survived_Sex <- kat_stat(data$Survived, data$Sex)
#Cramer  normKont
#0.5409359 0.6728632
zusammenhang_Survived_Pclass <- kat_stat(data$Survived, data$Pclass)
#Cramer  normKont
#0.3398174 0.4550200
zusammenhang_Survived_Side <- kat_stat(data$Survived, data$Side)
#Cramer   normKont
#0.05982927 0.08446033
zusammenhang_Survived_Deck <- kat_stat(data$Survived, data$Deck)
#Cramer  normKont
#0.1182824 0.1661186
zusammenhang_Survived_Anrede <- kat_stat(data$Survived, data$Anrede)
#Cramer  normKont
#0.5796337 0.7092011
# a-iv Zusammenhang zwischen einer metrischen und einer dichotomen Variable (z.B. Alter und Überlebensstatus)
zusammenhang_Survived_Age <- analyzeMetricDichotomous(data$Age, data$Survived)
# p-Wert des t-Tests liegt bei 0,009
zusammenhang_Survived_Fare <- analyzeMetricDichotomous(data$Fare, data$Survived)
# p-Wert des t-Tests liegt bei p-value = 2.699e-11
zusammenhang_Survived_SibSp <- analyzeMetricDichotomous(data$SibSp, data$Survived)
# p-Wert des t-Tests liegt bei p-value = 0.2327
zusammenhang_Survived_Parch <- analyzeMetricDichotomous(data$Parch, data$Survived)
# p-Wert des t-Tests liegt bei p-value = 0.01339
# a-v Visualisierung
create_categorical_plot(data_kategorial, a = 1, b = 3)
# a-v Visualisierung
create_categorical_plot(data_kategorial, a = 2, b = 2)
## Ließt die Datei unverarbeitet ein
data <- read.csv("titanic.csv")
## Eine Funktion zum extrahieren der Anreden
anrede <- function(x) {
n <- length(x)
an <- vector(mode = "character", length = n)
for (i in 1:n) {
temp1 <- regexpr(", ", x[i]) + 1
temp2 <- regexpr("\\.", x[i])
an[i] <- substr(x[i], temp1 + 1, temp2 - 1)
}
return(an)
}
# Anwendung auf die Daten und erstellung eines neuen Vektors für die Anreden
data$Anrede <- anrede(data$Name)
## Extrahieren der einzigartigen Anreden
unique(data$Anrede)
# [1] "Mr"           "Mrs"          "Miss"         "Master"       "Don"
# [6] "Rev"          "Dr"           "Mme"          "Ms"           "Major"
# [11] "Lady"         "Sir"          "Mlle"         "Col"          "Capt"
# [16] "the Countess" "Jonkheer"
## Zusammenfassen gleichbedeutender Anreden
comp <- function(x) {
for (i in 1:length(x)) {
if (x[i] == "Miss") {
x[i] <- "Ms"
}
else if (x[i] == "Mile") {
x[i] <- "Ms"
}
else if (x[i] == "Mme") {
x[i] <- "Mrs"
}
else if (x[i] == "Don") {
x[i] <- "Mr"
}
}
return(x)
}
data$Anrede <- comp(data$Anrede)
## Die anderen Anreden sind inhaltlich nicht exakt gleich und es ist zu
## erwarten das die betroffenen Personen sich jeweils in wichtigen
## Attributen unterscheide (Durchschnittsalter, etc)
## Faktorisierung von "Survived"
data$Survived <- factor(data$Survived, 0:1, c("No", "Yes"))
## Faktorisierung von "Sex"
data$Sex <- factor(data$Sex, c("male", "female"), c("Male", "Female"))
## Faktorisierung von "Embarked"
data$Embarked <- factor(data$Embarked, c("C", "Q", "S"), c("Cherbourg", "Queenstown", "Southampton"))
## Faktorisierung von "Pclass" (als ordered Faktor)
data$Pclass <- ordered(data$Pclass, 3:1)
## Funktion zum imputieren der fehlenden Werte
imp <- function(x, anrede) {
un <- unique(anrede)
n <- length(un)
m <- vector("numeric", n)
for (i in 1:n) {
m[i] <- mean(x[anrede == un[i]], na.rm = TRUE)
}
l <- length(x)
for (i in 1:l) {
if (is.na(x[i])) {
temp <- match(anrede[i], un)
x[i] <- m[temp]
}
}
return(x)
}
## Anwenden der Funktion
data$Age <- imp(data$Age, data$Anrede)
## Bearbeitung des Cabin-Vektors
data$Cabin[129] <- "E69"
data$Cabin[700] <- "G73"
data$Cabin[716] <- "G73"
data$Cabin[743] <- ""
data$Cabin[312] <- ""
## Funktion zum extrahieren der relevanten Daten aus dem Cabin Vektor
extract <- function(x) {
n <- length(x)
side <- vector("character", n)
deck <- vector("character", n)
for (i in 1:n) {
if (x[i] == "") {
x[i] <- NA
side[i] <- NA
deck[i] <- NA
}
else if (!grepl(" ", x[i])){
deck[i] <- substring(x[i], 1, 1)
side[i] <- ifelse((as.numeric(substring(x[i], 2)) %% 2) == 0, "Backboard", "Starboard")
}
else {
x[i] <- strsplit(x[i], " ")[[1]][1]
deck[i] <- substring(x[i], 1, 1)
side[i] <- ifelse((as.numeric(substring(x[i], 2)) %% 2) == 0, "Backboard", "Starboard")
}
}
return(data.frame(Side = side, Deck = deck))
}
## Anwendung der Funktion
temp <- extract(data$Cabin)
data$Side <- temp$Side
data$Deck <- temp$Deck
rm(temp)
## Faktorisierung von "Side" und "Deck"
data$Side <- as.factor(data$Side)
data$Deck <- as.factor(data$Deck)
## Entfernen der nicht mehr benötigten Variablen
remove <- c("PassengerID", "Name", "Ticket", "Cabin")
for (col in remove) {
data[[col]] <- NULL
}
rm(remove)
rm(col)
## Speichern der Daten zum späteren benutzen
save(data, file = "titanic.RData")
# moda - Funktion zur Bestimmung des Modalwerts
#        (am haeufigsten vorkommender Wert)
#
# Eingabe:
# v    - eine kategoriale Variable
#
# Ausgabe: Modalwert
moda <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
# CramersV - Funktion zur Berechnung von Cramers V
#
# Eingabe:  zwei Vektoren mit Auspraegungen von kategorialen Variablen gleicher
#           Laenge
#
# Ausgabe:  Cramers V
CramersV <- function(Merkmal1, Merkmal2){
Tabelle <- table(Merkmal1, Merkmal2)
m <- min(ncol(Tabelle)-1, nrow(Tabelle)-1)
n <- length(Merkmal1)
Liste <- chisq.test(Merkmal1, Merkmal2)
Chiquadrat <- as.numeric(Liste[1])
sqrt(Chiquadrat/(n*m))
}
# normKontingenz -  Funktion zur Berechnung des normierten
#                   Kontingenzkoeffizienten nach Pearson
#
# Eingabe:  zwei Vektoren mit Auspraegungen von kategorialen Variablen gleicher
#           Laenge
#
# Ausgabe:  normierter Kontingenzkoeffizient nach Pearson
normKontingenz <- function(Merkmal1, Merkmal2){
Tabelle <- table(Merkmal1, Merkmal2)
m <- min(ncol(Tabelle), nrow(Tabelle))
n <- length(Merkmal1)
Liste <- chisq.test(Merkmal1, Merkmal2)
Chiquadrat <- as.numeric(Liste[1])
Kontingenz <- sqrt(Chiquadrat/(Chiquadrat + n))
Korrektur <- sqrt((m-1)/m)
Kontingenz/Korrektur
}
# a-iv
# Helfer-Funktion zur Überprüfung und Vorbereitung der Daten
prepareDataForAnalysis <- function(metricVar, dichotomousVar) {
# Überprüfung, ob die metrische Variable numerisch ist
if (!is.numeric(metricVar)) {
stop("Die metrische Variable muss numerisch sein.")
}
# Überprüfung, ob die dichotome Variable genau zwei einzigartige Werte enthält
uniqueValues <- unique(dichotomousVar)
if (length(uniqueValues) != 2) {
stop("Die dichotome Variable muss genau zwei einzigartige Werte enthalten.")
}
# Umwandlung der dichotomen Variable in einen Faktor, falls noch nicht geschehen
if (!is.factor(dichotomousVar)) {
dichotomousVar <- factor(dichotomousVar)
}
# Rückgabe der vorbereiteten Daten
list(metricVar = metricVar, dichotomousVar = dichotomousVar)
}
# Laden der benoetigten Pakete
library(psych)
library(e1071)
#a-i
# metr_stat - Funktion zur Berechnung deskriptiver Statistiken fuer metrische
#             Variablen
#
# Eingabe:
# data      - Datensatz, fuer den die Statistiken berechnet werden sollen
#
# Ausgabe:
# result    - Ergebnismatrix als Dataframe mit allen berechneten Statistiken
metr_stat <- function(data) {
# Erstellen einer leeren Ergebnismatrix
result <- matrix(NA, nrow = length(data), ncol = 16)
colnames(result) <- c("Variable", "Anzahl", "NA-Anzahl", "Minimum", "Maximum",
"Spannweite", "Median", "Erste Quartil", "Letzte Quartil",
"Interquartilsabstand", "Arithm. Mittel",
"Varianz", "Standardabw.", "Variationskoef.",
"Schiefe", "Kurtosis")
# Iteration ueber die Variablen im Datensatz
for(i in 1:length(data)) {
var_name <- names(data)[i]
var_data <- data[[i]]
Max <- max(var_data)
Min <- min(var_data)
Mean <- mean(var_data)
Sd <- sd(var_data)
q1 <- quantile(var_data, 0.25, na.rm = TRUE)
q2 <- quantile(var_data, 0.75, na.rm = TRUE)
# Speichern der berechneten Statistiken in die Ergebnismatrix
result[i, 1] <- var_name
result[i, 2] <- length(var_data)
result[i, 3] <- sum(is.na(var_data))
result[i, 4] <- Min
result[i, 5] <- Max
result[i, 6] <- Max - Min
result[i, 7] <- median(var_data)
result[i, 8] <- q1
result[i, 9] <- q2
result[i, 10] <- q2 - q1
result[i, 11] <- Mean
result[i, 12] <- var(var_data)
result[i, 13] <- Sd
result[i, 14] <- Sd / Mean
result[i, 15] <- skewness(var_data)
result[i, 16] <- kurtosis(var_data)
}
# Rueckgabe der Ergebnismatrix als Dataframe
return(as.data.frame(result))
}
#a-ii
# kateg_stat - Funktion zur Berechnung deskriptiver Statistiken fuer kategoriale
#              Variablen
#
# Eingabe:
# data       - Datensatz, fuer den die Statistiken berechnet werden sollen
#
# Ausgabe:
# result     - Ergebnismatrix als Dataframe mit allen berechneten Statistiken
kateg_stat <- function(data){
# Erstellen einer leeren Ergebnismatrix
result <- matrix(NA, nrow = ncol(data), ncol = 5)
colnames(result) <- c("Variable", "Anzahl", "NA-Anzahl", "Modalwert",
"Relative Haeufigkeit")
# Iteration über die Variablen im Datensatz
for(i in 1:ncol(data)) {
var_name <- names(data)[i]
var_data <- data[[i]]
# Berechnung der Modalwert
modalwert <- moda(var_data)
# Berechnung der relativen Haeufigkeit
rel_h <- table(var_data) / length(var_data)
# Speichern der berechneten Statistiken in die Ergebnismatrix
result[i, 1] <- var_name
result[i, 2] <- length(var_data)
result[i, 3] <- sum(is.na(var_data))
result[i, 4] <- modalwert
result[i, 5] <- rel_h[as.character(modalwert)]
# Nur die relative Haeufigkeit des Modalwerts speichern
}
# Rückgabe der Ergebnismatrix als Dataframe
return(as.data.frame(result))
}
#a-iii
# kat_stat -  Funktion zur Berechnung bivariater deskriptiver Statistiken fuer
#             den Zusammenhang zweier kategorialer Variablen
#
# Eingabe:
# data1     - Vektor der Auspraegungen der ersten kategorialen Variable
# data2     - Vektor der Auspraegungen der zweiten kategorialen Variable
#
# Ausgabe:
# result    - benannter Vektor mit Cramers V und dem normierten
#             Kontingenzkoeffizienen nach Pearson
kat_stat <- function(data1, data2) {
c(Cramer = CramersV(data1, data2), normKont = normKontingenz(data1, data2))
}
#a-iv
# Funktion zur Analyse des Zusammenhangs zwischen einer metrischen und einer
#dichotomen Variable
analyzeMetricDichotomous <- function(metricVar, dichotomousVar) {
# Vorbereitung der Daten mit der Helfer-Funktion
preparedData <- prepareDataForAnalysis(metricVar, dichotomousVar)
metricVar <- preparedData$metricVar
dichotomousVar <- preparedData$dichotomousVar
# Berechnung der Mittelwerte für jede Gruppe der dichotomen Variable
means <- tapply(metricVar, dichotomousVar, mean, na.rm = TRUE)
# Durchführung eines t-Tests
t.testResult <- t.test(metricVar ~ dichotomousVar)
# Berechnung der Standardabweichungen für jede Gruppe
sds <- tapply(metricVar, dichotomousVar, sd, na.rm = TRUE)
# Ausgabe der Ergebnisse
list(
Means = means,
StandardDeviations = sds,
TTest = t.testResult
)
}
#
#* Diese Funktion visualisiert alle kategoriellen Variablen eines gegebenen
#* Dataframes.
#* "dataframe" enthält den Dataframe in welchem die Daten gespeichert sind,
#* "a" und "b" geben an die viele Plots pro Reihe/Spalte am Ende angezeigt
#* werden sollen. Um alle Plots einzeln zu bekommen beide auf 1 setzen.
create_categorical_plot <- function(dataframe, a = 1, b = 1) {
n <- length(dataframe[,1])
categorical_vars <- sapply(dataframe, is.factor)
par(mfrow = c(a, b))
# Plot für jede kategoriale Variable erstellen
for (col in names(dataframe)[categorical_vars]) {
cat_levels <- levels(dataframe[[col]])
cat_counts <- table(dataframe[[col]])/n
# Balkendiagramm erstellen
barplot(cat_counts, main = paste("Barplot for", col),
xlab = col, ylab = "Frequency", col = rainbow(length(cat_levels)))
}
}
attach(data)
#Ueberblick von Daten und deren Auspraegungen
str(data)
# Teildatensaetze
data_metrisch <- data[, 5:8]
data_kategorial <- data[, c(2:4, 9:12)]
# Berechnung von deskriptiven Statistiken fuer metrische Variablen
metr_stat(data_metrisch)
# Berechnung von deskriptiven Statistiken fuer kategoriale Variablen
kateg_stat(data_kategorial)
# a-iii Zusammenhang zwischen zwei kategorialen Variablen
zusammenhang_Survived_Sex <- kat_stat(Survived, Sex)
#Cramer  normKont
#0.5409359 0.6728632
#Diese Ergebnisse deuten auf einen mittleren bis hoeheren Zusammenhang zwischen
#Sex und Survived hin.
zusammenhang_Survived_Pclass <- kat_stat(Survived, Pclass)
#Cramer  normKont
#0.3398174 0.4550200
#Diese Ergebnisse deuten auf einen mittleren Zusammenhang zwischen
#Pclass und Survived hin.
zusammenhang_Survived_Side <- kat_stat(Survived, Side)
#Cramer   normKont
#0.05982927 0.08446033
#Diese Ergebnisse deuten darauf hin, dass es fast kein Zusammenhang zwischen
#Side und Survived gibt.
zusammenhang_Survived_Deck <- kat_stat(Survived, Deck)
#Cramer  normKont
#0.1182824 0.1661186
#Diese Ergebnisse deuten auf einen schwachen Zusammenhang zwischen
#Pclass und Survived hin.
zusammenhang_Survived_Anrede <- kat_stat(Survived, Anrede)
#Cramer  normKont
#0.5796337 0.7092011
#Diese Ergebnisse deuten auf einen mittleren bis hoeheren Zusammenhang zwischen
#Anrede und Survived hin.
# a-iv Zusammenhang zwischen einer metrischen und einer dichotomen Variable
zusammenhang_Survived_Age <- analyzeMetricDichotomous(Age, Survived)
# p-Wert des t-Tests liegt bei 0,009279
# Die Annahme der Unabhängigkeit der Variablen Age und Survived kann daher bei einem alpha
# von 0,05 (mit Bonferroni-Adjustierung 0,0125) abgelehnt werden.
zusammenhang_Survived_Fare <- analyzeMetricDichotomous(Fare, Survived)
# p-Wert des t-Tests liegt bei p-value = 2.699e-11
# Die Annahme der Unabhängigkeit der Variablen Fare und Survived kann daher bei einem alpha
# von 0,05 (mit Bonferroni-Adjustierung 0,0125) abgelehnt werden.
zusammenhang_Survived_SibSp <- analyzeMetricDichotomous(SibSp, Survived)
# p-Wert des t-Tests liegt bei p-value = 0.2327
# Die Annahme der Unabhängigkeit der Variablen SibSp und Survived kann nicht abgelehnt werden.
zusammenhang_Survived_Parch <- analyzeMetricDichotomous(Parch, Survived)
# p-Wert des t-Tests liegt bei p-value = 0.01339
# Die Annahme der Unabhängigkeit der Variablen Parch und Survived kann nicht abgelehnt werden,
# wenn ein alpha von 0,05 und eine Bonferroni-Adjustierung angewendet werden.
# a-v Visualisierung
#Der Balkendiagramm zeigt die Häufigkeiten, mit denen Passagiere an verschiedenen Orten an Bord gegangen sind.
#Ein überwältigender Anteil der Passagiere ist in Southampton an Bord gegangen (ungefähr 70%),
# gefolgt von einer deutlich kleineren Anzahl in Cherbourg, etwa 20%, und noch weniger aus Queenstown (circa 10%).
create_categorical_plot(data_kategorial, a = 1, b = 3)
